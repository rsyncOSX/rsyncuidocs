+++
author = "Thomas Evensen"
title = "Observers"
date = "2025-03-01"
tags = ["swift concurrency", "asynchronous", "notifications","observers"]
categories = ["technical details"]
+++

A key feature of RsyncUI is observation for two notifications:

- `NSNotification.Name.NSFileHandleDataAvailable`
- `Process.didTerminateNotification`

Without observation and required actions when observed, RsyncUI becomes useless. Both observations are linked to the external task executing the actual rsync task.

## Notifications

The first notification, `NSNotification.Name.NSFileHandleDataAvailable`, monitors when the external task generates output. To display the progress of a synchronization task, RsyncUI relies on monitoring the output from rsync. Therefore, the `â€”verbose` parameter to rsync is crucial. This parameter instructs rsync to output information during execution.

The second notification, `Process.didTerminateNotification`, monitors when the task is completed, e.g. terminated. Typically, a termination indicates task completion. However, it may also be an abort action from the user, which then sends an interrupt signal to the external task. If RsyncUI fails to detect this signal, RsyncUI will not comprehend when a synchronization task is completed.


## Three methods 

In RsyncUI, three methods for enabling observations of notifications have been introduced in the latest version 2.6.3. 

## Combine and Publisher

The Combine framework is utilized within the `ProcessRsync` and `ProcessCommand` objects, which is responsible for initiating external tasks, such as the `rsync` synchronize task. The `rsync` synchronize task is completed when the last notification is observed. By using Combine, a publisher is added to the Notification center. Every time the Notification center discover one of the notifications, it publish a message. 

```swift
// Combine, subscribe to NSNotification.Name.NSFileHandleDataAvailable
NotificationCenter.default.publisher(
  for: NSNotification.Name.NSFileHandleDataAvailable)
  .sink { [self] _ in
  ....
  }.store(in: &subscriptons)
// Combine, subscribe to Process.didTerminateNotification
NotificationCenter.default.publisher(
    for: Process.didTerminateNotification)
        .debounce(for: .milliseconds(500), scheduler: DispatchQueue.main)
        .sink { [self] _ in
        ....
        subscriptons.removeAll()
    }.store(in: &subscriptons)
```

## NotificationCenter and addObserver

The second method for observing notifications involves adding Observers to the Notification center. Upon the discovery of a notification, the completion handler is executed. The Process object is annotated to execute on the main thread. It appears that the addObserver closure is marked as Sendable, indicating that mutating properties within the closure must be asynchronous. This is due to *the Swift 6 language mode* and *strict concurrency checking*.

```swift
// Observers
var notificationsfilehandle: NSObjectProtocol?
var notificationstermination: NSObjectProtocol?
....
notificationsfilehandle =
    NotificationCenter.default.addObserver(forName: NSNotification.Name.NSFileHandleDataAvailable,
                                                   object: nil, queue: nil)
        { _ in
            Task {
                await self.datahandle(pipe)
            }
        }

notificationstermination =
    NotificationCenter.default.addObserver(forName: Process.didTerminateNotification,
                                                   object: task, queue: nil)
        { _ in
                Task {
                    // Debounce termination for 500 ms
                    try await Task.sleep(seconds: 0.5)
                    await self.termination()
                }
        }
```

Upon task completion, the Observers must be released to prevent a retain cycle and memory leak.

```swift
func termination() async {
        processtermination(output, config?.hiddenID)
        // Log error in rsync output to file
        if errordiscovered, let config {
            Task {
                await ActorLogToFile(command: config.backupID,
                                     stringoutputfromrsync: output)
            }
        }
        SharedReference.shared.process = nil
        NotificationCenter.default.removeObserver(notificationsfilehandle as Any,
                                                  name: NSNotification.Name.NSFileHandleDataAvailable,
                                                  object: nil)
        NotificationCenter.default.removeObserver(notificationstermination as Any,
                                                  name: Process.didTerminateNotification,
                                                  object: nil)
        Logger.process.info("ProcessRsyncObserving: process = nil and termination discovered")
    }
```

## NotificationCenter.Notifications and AsyncSequence

Quote Apple documentation: *"An asynchronous sequence of notifications generated by a notification center."* The for await loops iterates over the notifications and acts upon receiving. When the termination signal is observed, the tasks must also be canceled and Observers removed. 

```swift
// AsyncSequence
let sequencefilehandler = NotificationCenter.default.notifications(named: NSNotification.Name.NSFileHandleDataAvailable, object: nil)
let sequencetermination = NotificationCenter.default.notifications(named: Process.didTerminateNotification, object: nil)
// Tasks
var sequenceFileHandlerTask: Task<Void, Never>?
var sequenceTerminationTask: Task<Void, Never>?
....
sequenceFileHandlerTask = Task {
            for await _ in sequencefilehandler {
                await self.datahandle(pipe)
            }
        }
        
sequenceTerminationTask = Task {
            for await _ in sequencetermination {
                Task {
                    try await Task.sleep(seconds: 0.5)
                    await self.termination()
                }
            }
        }
```

Upon task completion, the Observers must be released, and corresponding Tasks must be canceled to prevent a retain cycle and memory leak.

```swift
func termination() async {
        processtermination(output, config?.hiddenID)
        // Log error in rsync output to file
        if errordiscovered, let config {
            Task {
                await ActorLogToFile(command: config.backupID,
                                     stringoutputfromrsync: output)
            }
        }
        SharedReference.shared.process = nil
        // Remove observers
        NotificationCenter.default.removeObserver(sequencefilehandler as Any,
                                                  name: NSNotification.Name.NSFileHandleDataAvailable,
                                                  object: nil)
        NotificationCenter.default.removeObserver(sequencetermination as Any,
                                                  name: Process.didTerminateNotification,
                                                  object: nil)
        // Cancel Tasks
        sequenceFileHandlerTask?.cancel()
        sequenceTerminationTask?.cancel()
        
        Logger.process.info("ProcessRsyncAsyncSequence: process = nil and termination discovered")
    }
```