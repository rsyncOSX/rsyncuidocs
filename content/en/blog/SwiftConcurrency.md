+++
author = "Thomas Evensen"
title = "Swift concurrency"
date = "2025-03-01"
tags = ["swift concurrency", "asynchronous"]
categories = ["technical details"]
+++

{{% pageinfo color="info" %}}

To commence, I must acknowledge that my proficiency in Swift concurrency is limited. While I possess a rudimentary comprehension of the subject matter, if you are perusing this blog and seeking further elaboration on the topic, I strongly recommend conducting a search and perusing articles from alternative sources that offer a more comprehensive understanding of Swift concurrency.

{{< /pageinfo >}}

RsyncUI is a graphical user interface (GUI) application; the majority of its operations are executed on the main thread. However, some resource-intensive tasks are performed on other threads managed by the cooperative thread pool (CTP), *excluding* and *not blocking* the main thread. How to the executors and CTP works and interacts is details I dont know about, and it is managed by the Swift runtime. There are three kinds of executors:

- the *main executor* manage jobs on the Main Thread
- the *global concurrent executor* and the *serial executor*, both executes jobs on threads from the CTP

Most work in RsyncUI are executed on the Main Thread. And by default, SwiftUI makes sure all UI-updates are performed on the Main Thread.  Below are some other tasks within RsyncUI, which are executed on the Main Thread:

- preparing of and execution of `rsync` synchronize tasks, preparing is computing the correct arguments for rsync 
- monitoring progress and termination of the real rsync tasks
	- monitoring progress is an asynchronous sequence running on the Main Thread, by asynchronous sequence of two specific notifications generated by the notification center
- some write and read operations

#### Swift concurrency and asynchronous execution

Concurrency and asynchronous execution are important parts in Swift. The latest version of Swift simplifies the writing of asynchronous code using Swift `async` and `await` keywords, as well as the `actor` protocol. RsyncUI does not require concurrency, but concurrency is automatically introduced by using `actors` , `async` and `await` keywords. It is an objective to execute most work synchronous on the main thread as long as it does not block the GUI.

Asynchronous execution can be performed both on the Main Thread and on background threads from the CTP. If executing asynchronous operations on the Main Thread it is important to utilize Swift's structured concurrency, async/await keywords. The await keyword is a suspension point if other and more important work needs access to the Main Thread.

#### Swift version 6 and the new concurrency model

Swift version 6 introduced strict concurrency checking. By enabling *Swift 6 language mode*  and *strict concurrency checking*, Xcode assists in identifying and resolving possible data races at compile time.

Quote swift.org: *"More formally, a data race occurs when one thread accesses memory while the same memory is being modified by another thread. The Swift 6 language mode eliminates these issues by preventing data races at compile time."*

RsyncUI adheres to the new concurrency model of Swift 6.

#### Cooperative thread pool (CTP)

The following tasks are executed asynchronous on threads from the CTP, adhering to the `actor` protocol:

- read tasks from file
- JSON data decoding and encoding
	- the decode and encode functions inherits the thread from the calling function
- read and sort log records
- preparing *output from rsync* for display
- preparing *data from the logfile* for display
- checking for updates to RsyncUI

Adhering to the actor protocol, all access to properties within an actor must be performed asynchronously. There are three types of executors, which manages jobs and put jobs on threads for execution. 

The above mentioned tasks are executed on threads from the CTP, and not on the`@MainActor`. The Swift concurrency runtime handles scheduling and execution, guaranteeing that all functions within an actor are  `nonisolated func`, which to my understanding, guarantees asynchronous execution on threads from the CTP.

##### Structured concurrency

Some concurrent functions within RsyncUI are structured by using `async let`. You may have several `async let`, and they will all be executed in *parallel* or *concurrent*. When all `async let` tasks are completed, the root task or parent task, will continue execution. 

```swift
func readconfigurations() {
    Task {
       	let monitornetworkconnection = SharedReference.shared.monitornetworkconnection
        let sshport = SharedReference.shared.sshport
        let actorReadSynchronizeConfigurationJSON = ActorReadSynchronizeConfigurationJSON()
        async let data = actorReadSynchronizeConfigurationJSON
                    .readjsonfilesynchronizeconfigurations(nil,
                                                           monitornetworkconnection,
                                                           sshport)
        rsyncUIdata.configurations = await data
    }
}
```

##### Unstructured concurrency

The code snippet below presents an *unstructured* concurrency.  The code within the `Task  { ... }` *may* be completed after the execution of the calling function, the parent,  is completed.  Upon the function's return, the UI is notified on the main thread if there is a new version available.

```swift
@MainActor
func somefunction() {
   // Some code
    Task {
      newversion.notifynewversion = await GetversionofRsyncUI().getversionsofrsyncui()
	}
  // Some code
}
```

Access to properties within an actor must be performed asynchronously, that is why the `Task  { ... }` above is requiered. The Swift runtime makes sure that only one thread a time get access to properties within an actor.  The code below is probably not an OK example.  The main reason for make this an actor is to execute it on a thread from the CTP for not block the Main Thread. 

```swift
actor GetversionofRsyncUI {
    nonisolated func getversionsofrsyncui() async -> Bool {
        do {
            let versions = await DecodeGeneric()
            if let versionsofrsyncui =
                try await versions.decodearraydata(VersionsofRsyncUI.self,
                                                   fromwhere: Resources().getResource(resource: .urlJSON))
            {
                let runningversion = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? ""
                let check = versionsofrsyncui.filter { runningversion.isEmpty ? true : $0.version == runningversion }
                if check.count > 0 {
                    return true
                } else {
                    return false
                }
            }
        } catch {
            return false
        }
        return false
    }
}
```
