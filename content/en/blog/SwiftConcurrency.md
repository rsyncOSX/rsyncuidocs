+++
author = "Thomas Evensen"
title = "Swift concurrency"
date = "2025-03-01"
tags = ["swift concurrency", "asynchronous"]
categories = ["technical details"]
+++

{{% pageinfo color="info" %}}

First, I must acknowledge that my understanding of Swift concurrency is limited. While I have a basic grasp of the subject, if you are reading this and seeking more detailed information, I strongly recommend searching for and reading articles from other sources that provide a more comprehensive explanation of Swift concurrency.

{{% /pageinfo %}}

RsyncUI is a graphical user interface (GUI) application; the majority of its operations are executed on the main thread. However, some resource-intensive tasks are performed on other threads managed by the cooperative thread pool (CTP), *excluding* and *not blocking* the main thread. How the executors and CTP work and interact are details I don't know aboutâ€”they are managed by the Swift runtime. There are three kinds of executors:

- the *main executor* manages jobs on the main thread
- the *global concurrent executor* and the *serial executor*, both execute jobs on threads from the CTP

Most work in RsyncUI is executed on the main thread. By default, SwiftUI ensures all UI updates are performed on the main thread. Below are some tasks within RsyncUI that are executed on the main thread:

- preparing and executing `rsync` synchronization tasks (preparing involves computing the correct arguments for rsync)
- monitoring progress and termination of the actual `rsync` tasks
	- monitoring progress is an asynchronous sequence running on the main thread, created by an asynchronous sequence of two specific notifications generated by the notification center
- some write and read operations

### Swift Version 6 and the New Concurrency Model

Swift version 6 introduced strict concurrency checking. By enabling *Swift 6 language mode* and *strict concurrency checking*, Xcode assists in identifying and resolving possible data races at compile time.

<div class="alert alert-danger" role="alert">

However, it is important to note that there are several compiler directives, configured within Xcode, that pertain to concurrency. I strongly recommend researching these directives and their respective meanings. Additionally, if you are migrating an existing project to the new concurrency settings, I suggest researching the process of migrating projects. I recommend reading blog posts about Swift concurrency from [Matt Massicotte](https://www.massicotte.org) and [Antoine van der Lee](https://www.avanderlee.com).

</div>

Quote from swift.org: *"More formally, a data race occurs when one thread accesses memory while the same memory is being modified by another thread. The Swift 6 language mode eliminates these issues by preventing data races at compile time."*

RsyncUI adheres to the new concurrency model of Swift 6.

### Swift Concurrency and Asynchronous Execution

Concurrency and asynchronous execution are important parts of Swift. The latest version of Swift simplifies writing asynchronous code using the `async` and `await` keywords, as well as the `actor` protocol. While RsyncUI doesn't inherently require concurrency, it is automatically introduced through the use of `actors`, `async`, and `await` keywords. The objective is to execute most work synchronously on the main thread, provided it doesn't block the GUI.

Asynchronous execution can be performed on both the main thread and background threads from the CTP. When executing asynchronous operations on the main thread, it is crucial to use Swift's structured concurrency, specifically the async/await keywords. The `await` keyword serves as a suspension point, allowing other and more critical tasks to access the main thread.

### Cooperative Thread Pool (CTP)

The following RsyncUI tasks are executed *asynchronously* on threads from the CTP, adhering to the actor protocol:

- read synchronization tasks from file
	- JSON data *decoding*: asynchronous decoding that inherits the thread from the actor reading data
    - JSON data *encoding*: synchronous encoding on the *main thread*
- read and sort log records
- delete log records
- preparing *output from rsync* for display
- preparing *data from the log file* for display
- checking for updates to RsyncUI

Adhering to the actor protocol, all access to properties within an actor must be performed asynchronously. There are only five actors in RsyncUI, but there are more asynchronous functions, some of which run on the main thread as well.

#### Structured Concurrency

Some concurrent functions within RsyncUI are structured using `async let`. You may have several `async let` statements, and they will all execute in *parallel* or *concurrently*. When all `async let` tasks are completed, the root task or parent task will continue execution.

Structured concurrency might also dictate the order of execution. The keyword `await` is a suspension point where execution waits until the asynchronous function is completed before continuing. If there are several `await` statements in sequence, the next one will execute when the current asynchronous task is completed.

#### Example of structured concurrency

Approximately 800 log records, comprising the total of 1500, are selected for deletion. Two operations are concurrently executed on a background thread: the actual deletion of log records and the updating of non-deleted records for display.

The deletion of logs commences on the main thread. The user selects the logs to be deleted, and the delete button either initiates the deletion process or aborts it. The `deletelogs()` function, an asynchronous function, is initiated on the main thread.

```
Button("Delete", role: .destructive) {
      	Task {
              await deletelogs(selectedloguuids)
            }
  }
```
The deletelogs starts on the main thread and jumps off to an background thread inside the `Task {}`. 

```
func deletelogs(_ uuids: Set<UUID>) async {
        Task {
        
            print("(1) start async let updatedRecords deletelogs")
            
            async let updatedRecords: [LogRecords]? = ActorReadLogRecordsJSON().deletelogs(
                uuids,
                logrecords: logrecords,
                profile: rsyncUIdata.profile,
                validhiddenIDs: validhiddenIDs
            )
            let records = await updatedRecords
            
            print("(2) awaited updatedRecords deletelogs from (1))")
            print("(3) start async let updatedRecords updatelogsbyhiddenID)")
            
            async let updatedLogs: [Log]? = ActorReadLogRecordsJSON().updatelogsbyhiddenID(records, hiddenID)
            logrecords = records
            logs = await (updatedLogs ?? [])
            
            print("(4) awaited updatedLogs from (3)")

            WriteLogRecordsJSON(rsyncUIdata.profile, records)
            selectedloguuids.removeAll()
        }
    }
```
The debug windows in Xcode display the following:

The actors also print whether they execute on the main thread. The first `async let` statement initiates execution, and the subsequent `await` statement for the result above (2) suspends the function's execution until the asynchronous result is computed. The `await` statement is crucial for suspending the execution of the function until the asynchronous result is available. And then the next (3) and (4).

```
(1) start async let updatedRecords deletelogs
ActorReadLogRecordsJSON: deletelogs() NOT on main thread, currently on <NSThread: 0xa49e3c200>{number = 18}
ActorReadLogRecordsJSON: DEINIT
(2) awaited updatedRecords deletelogs from (1))
(3) start async let updatedRecords updatelogsbyhiddenID)
ActorReadLogRecordsJSON: updatelogsbyhiddenID() NOT on main thread, currently on <NSThread: 0xa49e3c280>{number = 17}
ActorReadLogRecordsJSON: DEINIT
(4) awaited updatedLogs from (3)
WriteLogRecordsJSON: writeJSONToPersistentStore file:///Users/thomas/.rsyncosx/VPxxxxxxxx/WDBackup/logrecords.json
WriteLogRecordsJSON DEINIT
ActorReadLogRecordsJSON: updatelogsbyhiddenID() NOT on main thread, currently on <NSThread: 0xa4bb72800>{number = 19}
ActorReadLogRecordsJSON: DEINIT
```

